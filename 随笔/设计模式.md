## 设计模式
按照设计意图分类
| 意图   | 模式                                                         |
| ------ | ------------------------------------------------------------ |
| 接口型 | 适配器模式、外观模式、合成模式、桥接模式                     |
| 职责型 | 单例模式、观察者模式、调停者模式、代理模式、职责链模式、享元模式 |
| 构造型 | 构建者模式、工厂方法模式、抽象工厂模式、原型模式、备忘录模式 |
| 操作型 | 模板方法模式、状态模式、策略模式、命令模式、解释器模式       |
| 扩展型 | 装饰器模式、迭代器模式、访问者模式                           |

#### creational    
Factory  
定义一个用于创建对象的接口，让子类决定将哪一个类实例化。  
Abstract factory  
提供一个用于创建一系列相关或相互依赖的对象的接口，而无须指定具体的类。
Builder  
将一个复杂对象的构建与表示分离，使得相同的构建过程可以创建不同的表示。
Prototype  
用原型实例指定创建的对象，通过拷贝原型实例来创建对象。
Singleton  
保证一个类只有一个实例，并且提供一个它的全局访问点。  



#### structional  
Adapter  
将一个类的接口转换成另一个接口，使得原先接口不兼容的类一起工作。  
Bridge  
将抽象部分与实现部分分离，使得它们都可以独立变化。  
Composite  
将对象组合成树形结构，表示“部分--整体”的层次感。主要使得使用者以统一的方式来使用任意对象。关键是图元对象。  
Decorator  
动态的给对象添加额外的职责。
Fecade
为子系统中的一组接口添加统一的界面，是这些子系统更加容易使用。
Flyweight  
运用共享技术，支持大量细粒度对象。
Proxy  
为其他对象提供一个代理，以控制对这个对象的访问。


#### behavioral
Interprete  
给定一个语言，定义它文法一种表示，并定义一个解释器，该解释器用来解释语言中的语句。
Template  
定义一个操作中算法的骨架，将一些步骤延迟到子类。使得子类不改变算法的结构也可以重定义算法的一些步骤。
Chain Responsibility  
接触请求的发送者和接受者之间的耦合，使多个对象都有机会处理该请求。将这些对象连成一个链，沿着该链条传递请求，直到有一个对象处理。
Command  
将一个请求封装为一个对象，从而可以用不用请求参数化客户。  
Iterator  
提供一种方法顺序请求一个聚合对象中的参数，而不用暴露该对象的内部表示。  
Mediator  
用一个中介对象来封装一系列对象的交互。
Memento  
不破坏封装的前提下，捕获一个对象的内部状态并保存。
Observer  
定义一种对象之间一对多的依赖关系，一个对象状态改变时，所有依赖它的对象都得到通知，并自动刷新。  
Strategy  
定义一些列算法，一个个封装起来，使得他们可以相互替换。使得算法的变化可以独立于算法的使用对象。  
State   
允许一个对象在其内部状态改变时，改变它的行为。  
Visitor
一个作用于某对象结构中的个元素的操作。增加操作。






软件设计原则  
单一设计原则（SRP,Single Responsibility Principle）  
开闭原则（OCP,Open Close Principle）  
里氏替换原则（LSP,Liskow Substitution Principle）  
依赖倒置原则（DIP,Dependence Inversion Principle）  
接口隔离原则（ISP,Interface Segregation Principle）  
迪米特原则（LOD,Law of Detemer）  
-组合优于继承  
-委托