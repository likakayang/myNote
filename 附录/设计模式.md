## 设计模式
按照设计意图分类
| 意图   | 模式                                                         |
| ------ | ------------------------------------------------------------ |
| 接口型 | 适配器模式、外观模式、合成模式、桥接模式                     |
| 职责型 | 单例模式、观察者模式、调停者模式、代理模式、职责链模式、享元模式 |
| 构造型 | 构建者模式、工厂方法模式、抽象工厂模式、原型模式、备忘录模式 |
| 操作型 | 模板方法模式、状态模式、策略模式、命令模式、解释器模式       |
| 扩展型 | 装饰器模式、迭代器模式、访问者模式                           |

### 行为型模式
类和对象的交互，以及责任和算法的划分。

访问者模式
>在不改变数据结构的前提下，增加作用于一组对象元素的新功能。

模板模式
>定义一个算法结构，而将一些步骤延迟到子类实现。

策略模式
>定义一些列算法，把它们封装起来，并且可以使它们相互替换。

状态模式
>允许一个对象在其对象内部状态改变时改变它的行为。

观察者模式
>对象间的一对多的依赖关系。

备忘录模式
>在不破坏封装的前提下，保持对象的内部状态。

中介者模式
>用一个中介对象来封装一些列的对象交互。

迭代器模式
>一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。

解释器模式
>给定一个语言，定义它的文法的一种表示，并定义一个解释器。

命令模式
>将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。

责任链模式
>将请求的发送者和接收者解耦，使得多个对象都有处理这个请求得机会。

### 创建型模式
对象实例化的模式，创建型模式用于解耦对象的实例化过程。

单例模式
>某个类只能有一个实例，提供一个全局得访问点。

工厂方法模式
>定义一个创建对象的接口，让子类决定实例化那个类。

抽象工厂模式
>创建相关或依赖对象的家族，而无需明确指定具体类。

建造者模式
>封装一个复杂对象的构建过程，并可以按步骤构造。

原型模式
>通过复制现有的实例来创建新的实例。

简单工厂模式
>一个工厂类根据传入的参量决定创建出那一种产品类的实例。

### 结构型模式
把类或对象结合在一起形成一个更大的结构。

适配器模式
>将一个类的方法接口转换成客户希望的另一个接口。

桥接模式
>将抽象部分和它的实现部分分离。使它们都可以独立的变化。

组合模式
>将对象组合成树形结构以表示“部分-整体”的层次结构。

装饰模式
>动态的给对象添加新的功能。

外观模式
>对外提供一个统一的方法，来访问子系统中的一群接口。

享元模式
>通过共享技术来有效的支持大量细粒度的对象。

代理模式

>为其他对象提供一个代理以便控制这个对象的访问。   






软件设计原则  
单一设计原则（SRP,Single Responsibility Principle）  
开闭原则（OCP,Open Close Principle）  
里氏替换原则（LSP,Liskow Substitution Principle）  
依赖倒置原则（DIP,Dependence Inversion Principle）  
接口隔离原则（ISP,Interface Segregation Principle）  
迪米特原则（LOD,Law of Detemer）  
-组合优于继承  
-委托